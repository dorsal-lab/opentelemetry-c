# opentelemetry-c

This project is a library wrapper around the official [opentelemetry-cpp](https://github.com/open-telemetry/opentelemetry-cpp) library. Understanding [OpenTelemetry specification](https://opentelemetry.io/docs/reference/specification/) is a prerequisite.

## Table of Contents

- [opentelemetry-c](#opentelemetry-c)
  - [Table of Contents](#table-of-contents)
  - [Overview](#overview)
    - [Scope and goals](#scope-and-goals)
    - [Ownership and license](#ownership-and-license)
  - [Setup opentelemetry-c in your project](#setup-opentelemetry-c-in-your-project)
    - [Option 1: Use as a sub repo subdirectory](#option-1-use-as-a-sub-repo-subdirectory)
    - [Option 2: Build source and install](#option-2-build-source-and-install)
      - [Step 1: Building as a standalone CMake Project](#step-1-building-as-a-standalone-cmake-project)
      - [Step 2: Incorporating into an existing CMake Project](#step-2-incorporating-into-an-existing-cmake-project)
  - [Wrapper API summary](#wrapper-api-summary)
    - [Tracing initialization and tracers](#tracing-initialization-and-tracers)
    - [Attributes map](#attributes-map)
    - [Spans](#spans)
    - [Metrics](#metrics)
  - [Repository examples](#repository-examples)
  - [Docker](#docker)

## Overview

### Scope and goals

The OpenTelemetry [opentelemetry-cpp](https://github.com/open-telemetry/opentelemetry-cpp) project can be used to trace C++ microservices. However, if you want to trace C microservices, you should consider a high-level C binding, like this one. It's worth noting that this wrapper does not support all the features of the C++ official project.

### Ownership and license

This project is provided as-is, without any warranty or support. Use at your own risk.

## Setup opentelemetry-c in your project

You can use this project as a [sub repo subdirectory in your project](#use-as-a-sub-repo-subdirectory) or [install library and header files](#build-source-and-install).

We recommend using it as a sub-repo because it avoids the struggle of reinstalling the library every time we change the wrapper.

Whatever option you chose, you need :

- A supported platform: Windows, macOS or Linux if you're not planning to use the LTTngExporter. Otherwise Linux.
- A compatible C++ compiler supporting at least C++11.
- Git for fetching the project source code from the repository.
- CMake for building the project.
- [opentelemetry-cpp](https://github.com/open-telemetry/opentelemetry-cpp) v1.8.1. The library needs to be installed with `WITH_OTLP` and `WITH_OTLP_GRPC` options set. Refer to the project documentation for the installation.
- [LTTng](https://lttng.org/docs/v2.13/) v2.13 if you plan to use the LTTngExporter. Refer to the project documentation for the installation.

All these tools are installed by default in the [lttng-otelcpp](lttng-otelcpp.Dockerfile) image and pushed to GitHub Container Registry (see [lttng-otelcpp-deploy CI job](..github/workflows/ci.yml)). To access the image use :

```console
docker pull ghcr.io/augustinsangam/lttng-otelcpp:main
```

### Option 1: Use as a sub repo subdirectory

First, add this project as a sub-repo in a folder like `third-party/`.

```console
$ cd path/to/the/root/of/your/git/project
$ git submodule add https://github.com/augustinsangam/opentelemetry-c.git third-party/opentelemetry-c/
```

Then, in your project `CMakeLists.txt` :

- Set project options

  Some of the available CMake build variables we can use during CMake
  configuration:

  - `LTTNG_EXPORTER_ENABLED`: Whether to use LTTng exporter or not. If set to off, OTLP GRPC default exporter will be used. All telemetry data generated by `opentelemetry-cpp` library are described using [protocol buffers](https://developers.google.com/protocol-buffers). Those protocol buffers are serialized and exported in binary format to [LTTng](https://lttng.org/). LTTng logs all these binary data to [CTF files](https://diamon.org/ctf/). The [otel-replayer](https://github.com/augustinsangam/otel-replayer) project can be used to read the CTF files and export them to various observability backends (e.g. Jaeger, Prometheus).

    | Type of <br>telemetry data | Description | LTTng tracepoint | Status |
    |---|---|---|---|
    | traces<br>(spans) | A Span represents a unit of work or operation. <br>It tracks specific operations that a request makes, <br>painting a picture of what happened during the time in which that operation was executed. | opentelemetry:resource_spans<br>See [Ressources spans proto](https://github.com/open-telemetry/opentelemetry-proto/blob/v0.19.0/opentelemetry/proto/trace/v1/trace.proto#L48) and [OTLP ExportTraceServiceRequest](https://github.com/open-telemetry/opentelemetry-proto/blob/v0.19.0/opentelemetry/proto/collector/trace/v1/trace_service.proto#L42) | Implemented |
    | logs | A log is a timestamped message emitted by services or other components | opentelemetry:resource_logs<br>See [Ressources logs proto](https://github.com/open-telemetry/opentelemetry-proto/blob/v0.19.0/opentelemetry/proto/logs/v1/logs.proto#L48) and [OTLP ExportLogsServiceRequest](https://github.com/open-telemetry/opentelemetry-proto/blob/v0.19.0/opentelemetry/proto/collector/logs/v1/logs_service.proto#L42) | Work in progress |
    | metrics | Metrics are aggregations over a period of time of numeric data about your infrastructure or application | opentelemetry:resource_metrics<br>See [Ressources metrics proto](https://github.com/open-telemetry/opentelemetry-proto/blob/v0.19.0/opentelemetry/proto/metrics/v1/metrics.proto#L48) and [OTLP ExportMetricsServiceRequest](https://github.com/open-telemetry/opentelemetry-proto/blob/v0.19.0/opentelemetry/proto/collector/metrics/v1/metrics_service.proto#L42) | Int64 UpDown counter and Int64 Observable UpDown implemented |

    When not using `LTTNG_EXPORTER_ENABLED` variable, all telemetry data are exported to an [OpenTelemetry collector](https://opentelemetry.io/docs/collector/) using the [OTLP protocol](https://opentelemetry.io/docs/reference/specification/protocol/otlp/). Also, you can also configure the collector GRPC server using the following environment variables: `OTEL_EXPORTER_OTLP_METRICS_CERTIFICATE`, `OTEL_EXPORTER_OTLP_METRICS_COMPRESSION`, `OTEL_EXPORTER_OTLP_METRICS_ENDPOINT`, `OTEL_EXPORTER_OTLP_METRICS_HEADERS`, `OTEL_EXPORTER_OTLP_METRICS_INSECURE`, `OTEL_EXPORTER_OTLP_METRICS_TEMPORALITY_PREFERENCE`, `OTEL_EXPORTER_OTLP_METRICS_TIMEOUT`, `OTEL_EXPORTER_OTLP_TRACES_CERTIFICATE`,  `OTEL_EXPORTER_OTLP_TRACES_COMPRESSION`, `OTEL_EXPORTER_OTLP_TRACES_ENDPOINT`, `OTEL_EXPORTER_OTLP_TRACES_HEADERS`, `OTEL_EXPORTER_OTLP_TRACES_INSECURE`, `OTEL_EXPORTER_OTLP_TRACES_TIMEOUT`,
    Description of these environment variables [are available here](https://opentelemetry.io/docs/reference/specification/protocol/exporter/#configuration-options).

  - `BATCH_SPAN_PROCESSOR_ENABLED`: Whether to use Batching Span Processor or Simple Span Processor. [Read more about Span Processors here](https://opentelemetry.io/docs/reference/specification/trace/sdk/#span-processor).

  - `BUILD_EXAMPLES`: Whether to build [examples](examples/) provided in opentelemetry-c project.

  Here is how to setup these variables :

  ```cmake
  # CMakeLists.txt
  option(LTTNG_EXPORTER_ENABLED "Whether to use LTTng exporter or not. If set to off, OTLP GRPC default exporter will be used" ON)
  option(BATCH_SPAN_PROCESSOR_ENABLED "Whether to use Batching Span Processor or Simple Span Processor" ON)
  option(BUILD_EXAMPLES "Whether to build examples or not" OFF)
  ```

- Add `opentelemetry-c` folder :

  ```cmake
  # CMakeLists.txt
  add_subdirectory(third-party/opentelemetry-c)
  ```

The [opentelemetry-c-performance](https://github.com/augustinsangam/opentelemetry-c-performance) is an example of a CMake project using the wrapper as a sub-repo. This project extract benchmark from various wrapper use cases.

### Option 2: Build source and install

#### Step 1: Building as a standalone CMake Project

- Getting the opentelemetry-c source code:

  ```console
  # Change to the directory where you want to create the code repository
  $ git clone https://github.com/augustinsangam/opentelemetry-c.git
  ```

- Navigate to the repository cloned above, and create the CMake build configuration.

  ```console
  $ cd opentelemetry-c
  $ mkdir -p build && cd build 
  $ cmake -DBATCH_SPAN_PROCESSOR_ENABLED=ON \
      -DLTTNG_EXPORTER_ENABLED=ON \
      -DBUILD_EXAMPLES=OFF \
      -DBUILD_SHARED_LIBS=ON \
      -DCMAKE_INSTALL_PREFIX=/usr/local/ \
      ..
  ```

  CMake build variables are the same ones described in the [previous section](#option-1-use-as-a-sub-repo-subdirectory). The `-DBUILD_SHARED_LIBS=ON` [is used to build a shared library](https://cmake.org/cmake/help/latest/variable/BUILD_SHARED_LIBS.html). [`-DCMAKE_INSTALL_PREFIX`](https://cmake.org/cmake/help/latest/variable/CMAKE_INSTALL_PREFIX.html) set the directory in which the library will be installed.

- Install the header files for the API, and generated targets at the specified install location.

  ```console
  $ make -j <number of cores>
  $ make install
  ```

  The `$ make install` command may require root access since we are installing the library in `/usr/local` folder.

#### Step 2: Incorporating into an existing CMake Project

To use the library from a CMake project, you can locate it directly with `find_package` and use the imported targets from generated package configurations.

```cmake
# CMakeLists.txt
find_library(opentelemetry-c opentelemetry-c REQUIRED)

...

# In your targets
target_include_directories(<my_target> PRIVATE ${OPENTELEMETRY_C_INCLUDE_DIRS})
target_link_libraries(<my_target> PRIVATE ${OPENTELEMETRY_C_LIBRARIES})
```

The [opentelemetry-c-demo](https://github.com/augustinsangam/opentelemetry-c-demo) is an example of a CMake project using the installed version of the wrapper as the tracer. It's a Simple ZeroMQ client, proxy and server application.

## Wrapper API summary

### Tracing initialization and tracers

The following functions can be used for initializing and using tracers in applications. These tracers are used for creating spans that help in understanding the application flow.

```C
/**
 * @brief Initialize the tracer provider and context propagator
 *
 * Read more on :
 * https://opentelemetry.io/docs/reference/specification/trace/api/#tracerprovider
 * and
 * https://opentelemetry.io/docs/reference/specification/context/api-propagators/#textmap-propagator
 *
 * @param service_name The name of the service we are tracing
 * @param service_version The version of the service
 * @param service_namespace The service namespace
 * @param service_instance_id The host instance id
 */
void init_tracer_provider(const char *service_name, const char *service_version,
                          const char *service_namespace,
                          const char *service_instance_id);

/**
 * @brief Get the tracer object
 * The tracer object help in the future to create spans
 *
 * Read more on :
 * https://opentelemetry.io/docs/reference/specification/trace/api/#tracer
 *
 * @return void*
 */
void *get_tracer();

/**
 * @brief Deallocate all resources used by the tracer
 *
 * @param tracer The tracer we want to destroy
 */
void destroy_tracer(void *tracer);
```

### Attributes map

The following functions are available to create, modify, and destroy an attribute map:

```C
void *create_attr_map();
/**
 * @brief Create a map of attribute (std::map<std::string,
 * opentelemetry::common::AttributeValue>).
 *
 * See https://opentelemetry.io/docs/reference/specification/common/#attribute
 */
void set_bool_attr(void *attr_map, const char *key, int boolean_value);

/**
 * See https://opentelemetry.io/docs/reference/specification/common/#attribute
 */
void set_int32_t_attr(void *attr_map, const char *key, int32_t value);

/**
 * See https://opentelemetry.io/docs/reference/specification/common/#attribute
 */
void set_int64_t_attr(void *attr_map, const char *key, int64_t value);

/**
 * See https://opentelemetry.io/docs/reference/specification/common/#attribute
 */
void set_uint64_t_attr(void *attr_map, const char *key, uint64_t value);

/**
 * See https://opentelemetry.io/docs/reference/specification/common/#attribute
 */
void set_double_attr(void *attr_map, const char *key, double value);

/**
 * See https://opentelemetry.io/docs/reference/specification/common/#attribute
 */
void set_str_attr(void *attr_map, const char *key, const char *value);

/**
 * @brief Deallocate map memory
 */
void destroy_attr_map(void *attr_map);
```

### Spans

The following functions and types are available for creating, managing and ending spans in the OpenTelemetry tracing system.

```C
/**
 * @brief Define the SpanKind
 *
 * See https://opentelemetry.io/docs/reference/specification/trace/api/#spankind
 */
typedef enum { // NOLINTBEGIN
  SPAN_KIND_INTERNAL,
  SPAN_KIND_SERVER,
  SPAN_KIND_CLIENT,
  SPAN_KIND_PRODUCER,
  SPAN_KIND_CONSUMER
} span_kind_t; // NOLINTEND

/**
 * @brief Create a new span
 *
 * Read more on :
 * https://opentelemetry.io/docs/reference/specification/trace/api/#span-creation
 *
 * @param tracer The tracer
 * @param span_name The name of the span we are creating
 * @param span_kind The SpanKind
 * @param remote_context The remote context serialized. This argument is
 * optional when creating nested spans in the same thread
 * @return void* The span
 */
void *start_span(void *tracer, const char *span_name, span_kind_t span_kind,
                 const char *remote_context);

/**
 * @brief Extract the context from the current active span
 *
 * Use this method to get the context to pass around requests
 *
 * The function allocates memory for the return value. This memory must be freed
 * later.
 *
 * For now the context is a string. In future, it could be in a
 * binary format (See
 * https://github.com/open-telemetry/opentelemetry-specification/issues/437)
 *
 * @param span The span
 * @return char* The context serialized
 */
char *extract_context_from_current_span(void *span);

/**
 * @brief Define a span status
 *
 * See
 * https://opentelemetry.io/docs/reference/specification/trace/api/#set-status
 */
typedef enum { // NOLINTBEGIN
  SPAN_STATUS_CODE_UNSET,
  SPAN_STATUS_CODE_OK,
  SPAN_STATUS_CODE_ERROR
} span_status_code_t; // NOLINTEND

/**
 * @brief Set the status of an span
 *
 * Read more on :
 * https://opentelemetry.io/docs/reference/specification/trace/api/#span-operations
 *
 * @param span The span
 * @param code The status code
 * @param description A description. The description matters only for the error
 * status code
 */
void set_span_status(void *span, span_status_code_t code,
                     const char *description);

/**
 * @brief Set the span attributes
 *
 * Read more on :
 * https://opentelemetry.io/docs/reference/specification/trace/api/#span-operations
 *
 * @param span The span
 * @param attr_map The map with all attributes
 */
void set_span_attrs(void *span, void *attr_map);

/**
 * @brief Add a span event
 *
 * Read more on :
 * https://opentelemetry.io/docs/reference/specification/trace/api/#span-operations
 *
 * @param span The span
 * @param event_name The event name
 * @param attr_map The map with all event attributes
 */
void add_span_event(void *span, const char *event_name, void *attr_map);

/**
 * @brief Ends a deallocated memory relating to a span
 *
 * @param span The span we want to end
 */
void end_span(void *span);
```

### Metrics

The following functions are available for initializing and creating various types of metrics objects, such as counters. These metrics objects can be used to collect data on the performance of a service.

```C
/**
 * @brief Initialize the Meter Provider and Meter reader
 *
 * Read more on
 * https://opentelemetry.io/docs/reference/specification/metrics/sdk/#meterprovider
 * and
 * https://opentelemetry.io/docs/reference/specification/metrics/sdk/#metricreader
 *
 * @param service_name The name of the service we are tracing
 * @param service_version The version of the service
 * @param service_namespace The service namespace
 * @param service_instance_id The host instance id
 * @param export_interval_millis The time interval in milliseconds between two
 * consecutive exports
 * @param export_timeout_millis How long the export can run before it is
 * cancelled
 */
void init_metrics_provider(const char *service_name,
                           const char *service_version,
                           const char *service_namespace,
                           const char *service_instance_id,
                           int64_t export_interval_millis,
                           int64_t export_timeout_millis);

/**
 * @brief Create a int64 up down counter
 *
 * Read more on :
 * https://opentelemetry.io/docs/reference/specification/metrics/api/#updowncounter
 *
 * @param name Counter name
 * @param description A description of what the counter does
 * @return void* The counter
 */
void *create_int64_up_down_counter(const char *name, const char *description);

/**
 * @brief Increment or decrement the UpDownCounter by a fixed amount
 *
 * https://opentelemetry.io/docs/reference/specification/metrics/api/#add-1
 *
 * @param counter The counter
 * @param value The increment or decrement
 */
void int64_up_down_counter_add(void *counter, int64_t value);

/**
 * @brief Deallocate all resources used by the counter
 *
 * @param counter The counter
 */
void destroy_up_down_counter(void *counter);

/**
 * @brief Create a int64 asynchronous up down counter
 *
 * Read more on :
 * https://opentelemetry.io/docs/reference/specification/metrics/api/#asynchronous-updowncounter
 *
 * @param name Counter name
 * @param description A description of what the counter does
 * @return void* The counter
 */
void *create_int64_observable_up_down_counter(const char *name,
                                              const char *description);

/**
 * @brief Register an asynchronous up down counter callback
 *
 * Read more on :
 * https://opentelemetry.io/docs/reference/specification/metrics/api/#asynchronous-updowncounter-operations
 *
 * @param counter The counter
 * @param callback The callback is a function returning the increment to apply
 * to the counter
 * @return void* The callback registration that should be use to cancel it
 */
void *int64_observable_up_down_counter_register_callback(void *counter,
                                                         int64_t (*callback)());

/**
 * @brief Cancel an asynchronous up down counter callback registration
 *
 * Read more on :
 * https://opentelemetry.io/docs/reference/specification/metrics/api/#asynchronous-updowncounter-operations
 *
 * @param counter The counter
 * @param registration The callback registration
 */
void int64_observable_up_down_counter_cancel_registration(void *counter,
                                                           void *registration);

/**
 * @brief Deallocate all resources used by the counter
 *
 * @param counter The counter
 */
void destroy_observable_up_down_counter(void *counter);
```

## Repository examples

Some examples of wrapper usage can be found in [the examples folder](examples/).
To execute an example :

```console
$ ./run.sh <example>
```

example is either `basic`, `up-down-counter`, `observable-up-down-counter` or `client-server-socket`.

Refer to each example README.md to understand each of them.

## Docker

Instead of installing all dependencies before running examples, you can run examples directly in Docker.

```console
$ docker build -t opentelemetry-c .
Sending build context to Docker daemon  803.8kB
Step 1/6 : FROM ghcr.io/augustinsangam/lttng-otelcpp:main
...
Step 6/6 : CMD ./run.sh basic &&        ./run.sh up-down-counter &&     ./run.sh observable-up-down-counter &&  ./run.sh client-server-socket
 ---> Running in d1eeb864e1b1
Removing intermediate container d1eeb864e1b1
 ---> 45e569393564
Successfully built 45e569393564
Successfully tagged opentelemetry-c:latest
```

```console
$ docker run opentelemetry-c ./run.sh basic
Building basic-example target ...
-- The C compiler identification is GNU 10.4.0
-- The CXX compiler identification is GNU 10.4.0
-- Detecting C compiler ABI info
-- Detecting C compiler ABI info - done
-- Check for working C compiler: /usr/bin/gcc-10 - skipped
-- Detecting C compile features
-- Detecting C compile features - done
-- Detecting CXX compiler ABI info
-- Detecting CXX compiler ABI info - done
-- Check for working CXX compiler: /usr/bin/g++-10 - skipped
-- Detecting CXX compile features
-- Detecting CXX compile features - done
-- Found nlohmann_json: /usr/local/lib/cmake/nlohmann_json/nlohmann_jsonConfig.cmake (found version "3.10.5") 
-- Looking for pthread.h
-- Looking for pthread.h - found
-- Performing Test CMAKE_HAVE_LIBC_PTHREAD
-- Performing Test CMAKE_HAVE_LIBC_PTHREAD - Success
-- Found Threads: TRUE  
-- Found opentelemetry-cpp: /usr/local/include (Required is at least version "1.8.1") 
-- Found LTTngUST: /usr/local/lib/liblttng-ust.so;dl (found version "2.3.5") 
-- Configuring done
-- Generating done
-- Build files have been written to: /tmp/opentelemetry-c-build
[ 11%] Building CXX object CMakeFiles/opentelemetry-c.dir/src/opentelemetry_c.cpp.o
...
[100%] Built target basic-example
Starting a LTTng session ...
Spawning a session daemon
Session auto-20230326-230750 created.
Traces will be output to /tmp/opentelemetry-c/ctf-traces/basic
ust event opentelemetry:* created in channel channel0
ust context vtid added to all channels
Tracing started for session auto-20230326-230750
Starting basic example ...
Basic example starts ...!
Basic example ends ...!
Stop LTTng session ...
Waiting for data availability.
Tracing stopped for session auto-20230326-230750
View traces ...
[23:07:52.009282402] (+?.?????????) 32cb5db20ee3 opentelemetry:resource_spans: { cpu_id = 1 }, { vtid = 180 }, { _resource_spans_length = 481, resource_spans = [ [0] = 10, [1] = 252, [2] = 1, [3] = 10, [4] = 32, [5] = 10, [6] = 21, [7] = 116, [8] = 101, [9] = 108, [10] = 101, [11] = 109, [12] = 101, [13] = 116, [14] = 114, [15] = 121, [16] = 46, [17] = 115, [18] = 100, [19] = 107, [20] = 46, [21] ...
[23:07:52.404522461] (+0.395240059) 32cb5db20ee3 opentelemetry:resource_spans: { cpu_id = 1 }, { vtid = 180 }, { _resource_spans_length = 481, resource_spans = [ [0] = 10, [1] = 252, [2] = 1, [3] = 10, [4] = 32, [5] = 10, [6] = 21, [7] = 116, [8] = 101, [9] = 108, [10] = 101, [11] = 109, [12] = 101, [13] = 116, [14] = 114, [15] = 121, [16] = 46, [17] = 115, [18] = 100, [19] = 107, [20] = 46, [21] ...
[23:07:53.188366671] (+0.783844210) 32cb5db20ee3 opentelemetry:resource_spans: { cpu_id = 1 }, { vtid = 180 }, { _resource_spans_length = 481, resource_spans = [ [0] = 10, [1] = 252, [2] = 1, [3] = 10, [4] = 32, [5] = 10, [6] = 21, [7] = 116, [8] = 101, [9] = 108, [10] = 101, [11] = 109, [12] = 101, [13] = 116, [14] = 114, [15] = 121, [16] = 46, [17] = 115, [18] = 100, [19] = 107, [20] = 46, [21] ...
[23:07:53.188595441] (+0.000228770) 32cb5db20ee3 opentelemetry:resource_spans: { cpu_id = 1 }, { vtid = 180 }, { _resource_spans_length = 349, resource_spans = [ [0] = 10, [1] = 252, [2] = 1, [3] = 10, [4] = 32, [5] = 10, [6] = 21, [7] = 116, [8] = 101, [9] = 108, [10] = 101, [11] = 109, [12] = 101, [13] = 116, [14] = 114, [15] = 121, [16] = 46, [17] = 115, [18] = 100, [19] = 107, [20] = 46, [21] ...
Destroying LTTng session ...
Destroying session auto-20230326-230750..
Session auto-20230326-230750 destroyed
Done!
```
